# 双模型智能路由系统架构设计

## 1. 概述

本文档定义了一个双模型智能路由对话系统的架构。该系统旨在在处理常规对话和复杂任务时，能够动态、无缝地在“标准模型”和“增强模型”之间切换，以优化响应速度、成本和任务处理能力，同时保持对话的连贯性。

## 2. 核心需求

- **双模型结构**:
    - **标准模型 (Standard Model)**: 用于日常对话，优化速度和成本。
    - **增强模型 (Enhanced Model)**: 用于处理复杂任务，如代码生成、深度分析等。
- **智能路由**: 一个路由判断层，在调用主模型前分析用户输入，决定使用哪个模型。
- **上下文与提示词管理**:
    - 两个模型共享统一的对话历史。
    - 增强模型在激活时，其系统提示词由 **[基础提示词] + [专属增强提示词]** 组合而成。

## 3. 最终架构方案：高性能并行路由

为了在实现智能路由的同时最大化用户体验，我们采用结合了**启发式预过滤**、**并行准备**和**严格超时**的混合策略。

### 3.1. 架构流程图

```mermaid
graph TD
    A[用户输入] --> B{Bot.generateResponse};
    B --> H{启发式预过滤};
    H -- 匹配 --> I[直接确定模型(标准/增强)];
    H -- 不匹配 --> P{并行处理};
    
    subgraph P [并行处理]
        direction LR
        P1[调用路由模型 (不等待)] --> P3[等待路由决策 (有超时)];
        P2[准备标准模型请求 (不等待)] --> P3;
    end
    
    P --> D{路由决策结果};
    D -- 是'ENHANCED' --> E[准备增强模型请求];
    D -- 是'STANDARD'或超时 --> F[使用已准备好的标准请求];
    
    I --> G[准备请求];
    E --> G;
    F --> G;
    
    G --> Z[调用最终模型Adapter];
    Z --> Z_END[返回响应];
```

### 3.2. 路由机制详解

1.  **启发式预过滤 (Heuristic Pre-filtering)**:
    - 这是路由的第一道防线，以零延迟处理最明显的请求。
    - **规则A**: 当消息包含代码块 (如 ` ``` `) 时，立即判定为 **ENHANCED**。
    - **规则B**: 当消息长度小于或等于预设阈值（如5个词）时，立即判定为 **STANDARD**。

2.  **AI路由模型 (AI Router Model)**:
    - 对于未被启发式规则命中的请求，系统将调用一个轻量级、快速的AI模型来判断意图。
    - 该模型被赋予一个特定的系统提示词，指导它将用户请求分类为 `STANDARD` 或 `ENHANCED`。

### 3.3. 延迟优化策略

1.  **并行准备 (Parallel Preparation)**:
    - 在调用AI路由模型的同时，系统会立即开始准备**标准模型**的请求数据（包括组合提示词、上下文等）。
    - 如果最终决策是使用标准模型，大部分准备时间已经被隐藏，从而显著降低了用户的感知延迟。

2.  **严格超时 (Strict Timeout)**:
    - 为AI路由模型的API调用设置一个严格的、可配置的超时时间（例如：800毫秒）。
    - 如果路由模型未在规定时间内返回结果，系统将自动中断等待，并默认使用已准备好的标准模型请求，确保了最坏情况下的响应速度上限。

## 4. 配置项 (`config.ts`)

所有关键参数都将通过配置系统进行管理，以实现最大的灵活性。

```typescript
// 示意配置结构
IntelligentRouter: {
  Enabled: boolean;
  RouterModel: {
    AdapterId: string;
    RouterPrompt: string;
  };
  StandardModel: {
    AdapterId: string;
  };
  EnhancedModel: {
    AdapterId: string;
    EnhancedPrompt: string;
  };
  LatencyOptimization: {
    Enabled: boolean;
    RouterTimeout: number; // in milliseconds
    Heuristics: {
      ShortMessageThreshold: number;
      CodeBlockTriggersEnhanced: boolean;
    };
  };
}
```

## 5. 实现要点

- **模块化**: 路由逻辑将被封装在独立的、可测试的私有方法中。
- **鲁棒性**: 所有外部调用（尤其是路由模型）都将被包含在 `try...catch` 块中，任何失败都会安全地回退到使用标准模型，保证系统的可用性。
- **可维护性**: 通过将复杂性分解到不同的辅助函数中，顶层编排逻辑将保持清晰，易于理解和维护。